Main features of spark
----------------------

Build parsers at compile time and expose them both at compile-time and run-time.
First, deal with regular grammar, then with context-free grammars.
Parsers exposed will be used with generator features, allowing infinite
transformation of recognized languages. These generator features must be usable
both with regular grammars and context-free grammars.
spark is : transcription algorithms, grammars, transcripters.
spark deals with : user input at compile-time and run-time.
The goal of spark is provide facilities to transcript user input in user output
using grammars. Input can either be specified at compile time or run-time.

Compile time user input has a form of integral sequence. It is especially useful
for the user to define custome grammars. An exemple of such an user input is
showed in implementing the regular grammar of spark.

Run time user input has a form of an iterable sequence formed by a pair of
iterator. It is especially useful to parse/transform the input to an output
accessible to the run time as well (for instance a JSON parser).

1°) Grammars
  1.1°) Regular grammars
    1.1.1°) Main entities of regular grammar definition string
    1.1.2°) Writing symbols
      1.1.2.1°) Simple symbols, inclusive and exclusive
      1.1.2.2°) Meta character for symbol definitions
    1.1.2°) Writing groups
  1.2°) Context-free grammars
2°) Transcriptors
  2.1°) Transcriptors for compile-time
  2.2°) Transcriptors for run-time
3°) Transcription algorithms
  3.1°) Transcription algorithms for compile-time
  3.2°) Transcription algorithms for run-time

1°) Grammars
------------
Grammars are a key concept of spark. It is one of the central entities to be
used in conjunction with transcriptors and transcription algorithms. These
grammars are used to recognize and input as a specific language. They are
declined in two versions : regular and context-free.

  1.1°) Regular Grammars
  ----------------------
The spark's regular grammar is the first that has been designed. A regular
grammar is defined by a string or an array of char in the world of C++.
Moreover, the grammar definition must be defined at compile time and be formed
with very precise elements with a strict syntax.

    1.1.1°) Main entities of regular grammar definition string
    ----------------------------------------------------------
Here are presented the top-level entities of regular grammar definition.

First, there is the document line or document block. It consists in a string
delimited by a starting sequence of '/*', without quotes and ending with the
sequence '*/', without quotes. It is just like a C multi-line comment. Any
character is allowed between these delimiters.
The document block is simply ignored while grammar is used to recognize an
language. It can be placed anywhere between grammar's entity definitions.
Documentation block have no special meaning in the grammar interpretation, it
only serves a documentation purposes for one who design/read the grammar.

Next, we have the symbol definitions block. This is a mandatory element of a
grammar definition. A symbol block definition is defined by a starting macro
named 'BEGIN_SYMBOLS;' (without quotes) and ends with an ending macro named
'END_SYMBOLS;' (without quotes). Between these 2 macro usage, there are symbols
definitions. Note the ';' character at the end of each macro. This is the end
statement character and it is mandatory.
Any regular grammar definition must contain one and only one symbol block
definition.

Next, we have the group definitions block. This is a mandatory element of a
grammar definition. A group block definition is defined by a starting macro
named 'BEGIN_GROUPS;' (without quotes) and ends with an ending macro named
'END_GROUPS;' (without quotes). Between these 2 macro usage, there are groups
definitions. Note the ';' character at the end of each macro. This is the end
statement character and it is mandatory.  Any regular grammar definition must
contain one and only one group block definition.

Finally, there is another main entity that is similar to the document line in
its meaning. This is the white space characters. White space characters are the
space : ' ', the horizontal tab : '	', the end line characters : '\n' and '\r'.
Like the documentation block, the white space characters don't have any meaning
in grammar interpretation but they could be used as symbols if escaped (we'll
see that later)

To summarize, a warp regular grammar definition string is built with :
- one or several documentation blocks placed between grammar entities,
- one and only one symbol definition block, defined before the group definition
  block,
- one and only one group definition block, defined after the symbol definition
  block,
- one or several white space characters.

Here is an overview of a warp regular grammar definition string, in C++ the
language :

auto warp_regular_grammar_definition_string =
  "/* This is an overview. Go ahead and read next chapters in order to see how"
  " * is built a true warp regular grammar definition. Note that this comment"
  " * block can contain any character and is ended here. */"

  "/* Mandatory symbol definition block. Must be defined only once and before"
  " * the group block definition. */"
  "BEGIN_SYMBOLS;"
  "/* contains all symbol definitions. More on that later. */"
  "END_SYMBOLS;"

  "/* Mandatory group definition block. Must be defined only once and after"
  " * the group block definition. Note that you can use raw string literal. */"
  R"groups(
  BEGIN_GROUPS;
  /* contains all group definitions. more on that later. */
  END_GROUPS;
  )groups"

    1.1.2°) Writing symbols
    -----------------------
This section describes how to write symbol defintions inside a symbol block.
A symbol is a logical object that can be compared to a single letter (for
instance a 'b'). A symbol can be a letter or anything but some letters.

Considering this, there is two categories of symbol : inclusive and exclusive.
An inclusive symbol represents a letter (just like 'c'). An exclusive symbol is
any letter but those specified. it can be seen as a negative character class in
a regular expression (for instance [^abc] is anything but 'a', 'b' or 'c').

      1.1.2.1°) Simple symbols, inclusive and exclusive
      -------------------------------------------------
There is several way to write symbol. The basic form is presented here, inside a
symbol group definition :

a = a;

Pretty simple isn't it? This line define a symbol named 'a', recognizing the 'a'
letter. The left hand side of this definition is the symbol name. An equal sign
define the value of a symbol, the right hand side is the symbol value. The
finishing semicolon is mandatory and denotes the end of the symbol definition.

Below is another example of symbol definition, but, this is an exclusive one
that is defined here :

no_digit = -0123456789;

Here, the symbol name is 'no_digit'. It is an exclusive symbol because the right
hand side of the symbol definition begin with a '-' character. Such a character
is called a meta-character and has a special meaning. The meaning of '-' is "all
but letters specified after it". The symbol defined above is similar to the
regular expression class [^0-9].

      1.1.2.2°) Meta character for symbol definitions
      -----------------------------------------------
