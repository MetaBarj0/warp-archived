Main features of spark
----------------------

Build parsers at compile time and expose them both at compile-time and run-time.
First, deal with regular grammar, then with context-free grammars.
Parsers exposed will be used with generator features, allowing infinite
transformation of recognized languages. These generator features must be usable
both with regular grammars and context-free grammars.
spark is : transcription algorithms, grammars, transcriptors.
spark deals with : user input at compile-time and run-time.
The goal of spark is provide facilities to transcript user input in user output
using grammars. Input can either be specified at compile time or run-time.

Compile time user input has a form of integral sequence. It is especially useful
for the user to define custom grammars. An exemple of such an user input is
showed in implementing the regular grammar of spark.

Run time user input has a form of an iterable sequence formed by a pair of
iterator. It is especially useful to parse/transform the input to an output
accessible to the run time as well (for instance a JSON parser).

1°) Grammars
  1.1°) Regular grammars
    1.1.1°) Main entities of regular grammar definition string
    1.1.2°) Writing symbols
      1.1.2.1°) Simple symbols, inclusive and exclusive
      1.1.2.2°) Meta character for symbol definitions
        1.1.2.2.1°) The '-' meta character
        1.1.2.2.2°) The '=' meta character
        1.1.2.2.3°) The ';' meta character
        1.1.2.2.4°) The 'white spaces' meta characters
        1.1.2.2.5°) The '`' pairs meta character
      1.1.2.3°) Defining symbols with macros
        1.1.2.3.1°) The BASIC_SYMBOLS macro
    1.1.2°) Writing groups
      1.1.2.1°) Name resolution lookup
      1.1.2.2°) Rules to write valid groups
      1.1.2.3°) Use closure in group definitions
        1.1.2.3.1°) Unary closures
          1.1.2.3.1.1°) One to one
          1.1.2.3.1.2°) One to many
          1.1.2.3.1.3°) Zero to one
          1.1.2.3.1.4°) Zero to many
        1.1.2.3.2°) Binary closures
          1.1.2.3.2.1°) Concatenation
          1.1.2.3.2.2°) Alternation
      1.1.2.4°) Defining groups with macros
        1.1.2.4.1°) The CONCATENATE_GROUPS macro
        1.1.2.4.2°) The ALTERNATE_GROUPS macro
  1.2°) Context-free grammars
2°) Transcriptors
  2.1°) Transcriptors for compile-time
  2.2°) Transcriptors for run-time
3°) Transcription algorithms
  3.1°) Transcription algorithms for compile-time
  3.2°) Transcription algorithms for run-time

1°) Grammars
------------
Grammars are a key concept of spark. It is one of the central entities to be
used in conjunction with transcriptors and transcription algorithms. These
grammars are used to recognize and input as a specific language. They are
declined in two versions : regular and context-free.

  1.1°) Regular Grammars
  ----------------------
The spark's regular grammar is the first that has been designed. A regular
grammar is defined by a string or an array of char in the world of C++.
Moreover, the grammar definition must be defined at compile time and be formed
with very precise elements with a strict syntax.

    1.1.1°) Main entities of regular grammar definition string
    ----------------------------------------------------------
Here are presented the top-level entities of regular grammar definition.

First, there is the document line or document block. It consists in a string
delimited by a starting sequence of '/*', without quotes and ending with the
sequence '*/', without quotes. It is just like a C multi-line comment. Any
character is allowed between these delimiters.
The document block is simply ignored while grammar is used to recognize an
language. It can be placed anywhere between grammar's entity definitions.
Documentation block have no special meaning in the grammar interpretation, it
only serves a documentation purposes for one who design/read the grammar.

Next, we have the symbol definitions block. This is a mandatory element of a
grammar definition. A symbol block definition is defined by a starting macro
named 'BEGIN_SYMBOLS;' (without quotes) and ends with an ending macro named
'END_SYMBOLS;' (without quotes). Between these 2 macro usage, there are symbols
definitions. Note the ';' character at the end of each macro. This is the end
statement character and it is mandatory.
Any regular grammar definition must contain one and only one symbol block
definition.

Next, we have the group definitions block. This is a mandatory element of a
grammar definition. A group block definition is defined by a starting macro
named 'BEGIN_GROUPS;' (without quotes) and ends with an ending macro named
'END_GROUPS;' (without quotes). Between these 2 macro usage, there are groups
definitions. Note the ';' character at the end of each macro. This is the end
statement character and it is mandatory.  Any regular grammar definition must
contain one and only one group block definition.

Finally, there is another main entity that is similar to the document line in
its meaning. This is the white space characters. White space characters are the
space : ' ', the horizontal tab : '	', the end line characters : '\n' and '\r'.
Like the documentation block, the white space characters don't have any meaning
in grammar interpretation but they could be used as symbols if escaped (we'll
see that later)

To summarize, a warp regular grammar definition string is built with :
- one or several documentation blocks placed between grammar entities,
- one and only one symbol definition block, defined before the group definition
  block,
- one and only one group definition block, defined after the symbol definition
  block,
- one or several white space characters.

Here is an overview of a warp regular grammar definition string, in C++ the
language :

auto warp_regular_grammar_definition_string =
  "/* This is an overview. Go ahead and read next chapters in order to see how"
  " * is built a true warp regular grammar definition. Note that this comment"
  " * block can contain any character and is ended here. */"

  "/* Mandatory symbol definition block. Must be defined only once and before"
  " * the group block definition. */"
  "BEGIN_SYMBOLS;"
  "/* contains all symbol definitions. More on that later. */"
  "END_SYMBOLS;"

  "/* Mandatory group definition block. Must be defined only once and after"
  " * the group block definition. Note that you can use raw string literal. */"
  R"groups(
  BEGIN_GROUPS;
  /* contains all group definitions. more on that later. */
  END_GROUPS;
  )groups"

    1.1.2°) Writing symbols
    -----------------------
This section describes how to write symbol defintions inside a symbol block.
A symbol is a logical object that can be compared to a single letter (for
instance a 'b'). A symbol can be a letter or anything but some letters.

Considering this, there is two categories of symbol : inclusive and exclusive.
An inclusive symbol represents a letter (just like 'c'). An exclusive symbol is
any letter but those specified. it can be seen as a negative character class in
a regular expression (for instance [^abc] is anything but 'a', 'b' or 'c').

      1.1.2.1°) Simple symbols, inclusive and exclusive
      -------------------------------------------------
There is several way to write symbol. The basic form is presented here, inside a
symbol group definition :

a = a;

Pretty simple isn't it? This line define a symbol named 'a', recognizing the 'a'
letter. The left hand side of this definition is the symbol name. An equal sign
define the value of a symbol, the right hand side is the symbol value. The
finishing semicolon is mandatory and denotes the end of the symbol definition.
An inclusive symbol definition can only recognize a single letter, here the 'a'.

Below is another example of symbol definition, but, this is an exclusive one
that is defined here :

no_digit = -0123456789;

Here, the symbol name is 'no_digit'. It is an exclusive symbol because the right
hand side of the symbol definition begin with a '-' character.
An exclusive symbol definition can recognize all character but those specified
after the '-' meta-character, here, this symbol can recognize any letter but 0,
'1','2','3','4','5','6','7','8' and '9'.
Note that symbol name must be unique throughout the symbol definitino block.
Giving the same name to several symbol is invalid.

      1.1.2.2°) Meta character for symbol definitions
      -----------------------------------------------
A meta character for a symbol definition is a character that has a special
meaning. Such a character cannot be used as is in a symbol definition without
altering the symbol definition itself. Below is a list of each meta character
that one can find in a symbol definition and how they can be used.

        1.1.2.2.1°) The '-' meta character
        ----------------------------------
Allows the definition of exclusive symbols. An exclusive symbol is a symbol that
recognizes all but letter specified, just like the negative character class of a
regular expression.
To obtain its meta-meaning, the '-' symbol must be specified as the first
character in the right hand-side of the symbol definition. If placed elsewhere
in the symbol definition, it loses its meta-meaning and is considered as a raw
'-' character.

        1.1.2.2.2°) The '=' meta character
        ----------------------------------
The assignation meta-character is the link between a symbol name and the letter
it recognize or letters it doesn't recognize. To obtain its meta-meaning the '='
character must be placed between the symbol name and the symbol defintion. As a
result, the '=' character is illegal in a symbol name and subsequent uses of '='
in the symbol definition are treated just as raws '=' characters.

        1.1.2.2.3°) The ';' meta character
        ----------------------------------
This is the end of symbol definition character. Each symbol definition must be
terminated by a ';'. Though it is a meta-character, the ';' gains its
meta-meaning only at the ultimate end of a symbol definition and, as a result,
can be used in symbol names.

        1.1.2.2.4°) The 'white spaces' meta characters
        ----------------------------------------------
These meta-characters are a bit special as they don't possess a real
meta-meaning. Therefore, they can be used as separator to enhance the
readability of symbol definitions. A white space character is either a space
(' '), an horizontal tab ('\t') or an end of line ('\r', '\n'). Besides being
used to enance readability of symbol definitions, they also can be used between
mais grammar definition entities (documentation blocks, symbol and group
defintion blocks, symbol and group definitions, symbol and group names and their
definition at right hand side). As a consequence, white space meta-characters
cannot be used as symbol names.

        1.1.2.2.5°) The '`' pairs meta character
        ----------------------------------------
These are a special beast. First, they are used to escape the meta-meaning of
other meta-character (including the '`'). Second, they have to be used as pair
to be effective : each meta-character inside a pair of '`' loose immediately its
meta-meaning. They can only be used in the right hand side of a symbol
definition and the opening '`' must be the first character for an inclusive
symbol definition. It must be the first character specified after the '-' in the
case of an exclusive symbol definition. If not specified at first character
after the '-' meta-character, the '`' immediately looses its meta-meaning (only
applies when defining an exclusive symbol). Using a pair of '`' with nothing
inside is invalid. If you want to escape the '`' character, it must be the first
character specified right after the opening '`' of the pair both for an
exclusive symbol definition and an inclusive symbol definition (that can only
take care of an unique letter anyway).
More examples of usage later.

      1.1.2.3°) Defining symbols with macros
      --------------------------------------
Examples above show how to define symbols with an unitary manner. Defining a lot
of symbol this way could be cumbersome and error-prone. Symbol definition macros
are here to solve these issues.

        1.1.2.3.1°) The BASIC_SYMBOLS macro
        -----------------------------------
This macro is designed to be used as a shortcut to define several INCLUSIVE
symbols at once. The way it works is simple, it defines as much as symbols
specified those the name is strictly equal to the letter that is recognized. As
usula, this statement must be terminated by a ';' meta-character.
It is good to know that there is some limit in letter used with this method. All
rules that are in place for symbol names apply on symbol definition with this
macro. As a result, you cannot use white spaces and the '=' letter with this
macro as it could lead to attempt to create symbol with a white space or an '='
name, that is illegal. Using this macro is also a way to escape the meta-meaning
of some meta-characters (except '=' and white spaces). As above, the usage of
this macro is restricted in a symbol definition block.
Here is an example of this macro usage :

BASIC_SYMBOLS helowrd;

The BASIC_SYMBOLS usage above is strictly similar to :

h = h;
e = e;
l = l;
o = o;
w = w;
r = r;
d = d;

I'm sure it won't be hard to convince you that using this macro is helpful when
dealing with simple inclusive symbols.

    1.1.2°) Writing groups
    ----------------------
