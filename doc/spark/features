Main features of spark
----------------------

Build parsers at compile time and expose them both at compile-time and run-time.
First, deal with regular grammar, then with context-free grammars.
Parsers exposed will be used with generator features, allowing infinite
transformation of recognized languages. These generator features must be usable
both with regular grammars and context-free grammars.
spark is : transcription algorithms, grammars, transcriptors.
spark deals with : user input at compile-time and run-time.
The goal of spark is provide facilities to transcript user input in user output
using grammars. Input can either be specified at compile time or run-time.

Compile time user input has a form of integral sequence. It is especially useful
for the user to define custom grammars. An exemple of such an user input is
showed in implementing the regular grammar of spark.

Run time user input has a form of an iterable sequence formed by a pair of
iterator. It is especially useful to parse/transform the input to an output
accessible to the run time as well (for instance a JSON parser).

1°) Grammars
  1.1°) Regular grammars
    1.1.1°) Main entities of regular grammar definition string
    1.1.2°) Writing symbols
      1.1.2.1°) Simple symbols, inclusive and exclusive
      1.1.2.2°) Meta-characters for symbol definitions
        1.1.2.2.1°) The '-' meta character
        1.1.2.2.2°) The '=' meta character
        1.1.2.2.3°) The ';' meta character
        1.1.2.2.4°) The 'white spaces' meta characters
        1.1.2.2.5°) The '`' pairs meta character
      1.1.2.3°) Defining symbols with macros
        1.1.2.3.1°) The BASIC_SYMBOLS macro
    1.1.3°) Writing groups
      1.1.3.1°) Rules to write valid groups
      1.1.3.2°) Use closure in group definitions
        1.1.3.2.1°) Unary closures
          1.1.3.2.1.1°) Name resolution lookup
          1.1.3.2.1.2°) One to one
          1.1.3.2.1.3°) One to many
          1.1.3.2.1.4°) Zero to one
          1.1.3.2.1.5°) Zero to many
        1.1.3.2.2°) Binary closures
          1.1.3.2.2.1°) Name resolution lookup
          1.1.3.2.2.2°) Concatenation
          1.1.3.2.2.3°) Alternation
      1.1.3.3°) Meta characters for group definitions
      1.1.3.4°) Defining groups with macros
        1.1.3.4.1°) The CONCATENATE_GROUPS macro
        1.1.3.4.2°) The ALTERNATE_GROUPS macro
  1.2°) Context-free grammars
2°) Transcriptors
  2.1°) Transcriptors for compile-time
  2.2°) Transcriptors for run-time
3°) Transcription algorithms
  3.1°) Transcription algorithms for compile-time
  3.2°) Transcription algorithms for run-time

1°) Grammars
------------
Grammars are a key concept of spark. It is one of the central entities to be
used in conjunction with transcriptors and transcription algorithms. These
grammars are used to recognize and input as a specific language. They are
declined in two versions : regular and context-free.

  1.1°) Regular Grammars
  ----------------------
The spark's regular grammar is the first that has been designed. A regular
grammar is defined by a string or an array of char in the world of C++.
Moreover, the grammar definition must be defined at compile time and be formed
with very precise elements with a strict syntax.

    1.1.1°) Main entities of regular grammar definition string
    ----------------------------------------------------------
Here are presented the top-level entities of regular grammar definition.

First, there is the document line or document block. It consists in a string
delimited by a starting sequence of '/*', without quotes and ending with the
sequence '*/', without quotes. It is just like a C multi-line comment. Any
character is allowed between these delimiters.
The document block is simply ignored while grammar is used to recognize an
language. It can be placed anywhere between grammar's entity definitions.
Documentation block have no special meaning in the grammar interpretation, it
only serves a documentation purposes for one who design/read the grammar.

Next, we have the symbol definitions block. This is a mandatory element of a
grammar definition. A symbol block definition is defined by a starting macro
named 'BEGIN_SYMBOLS;' (without quotes) and ends with an ending macro named
'END_SYMBOLS;' (without quotes). Between these 2 macro usage, there are symbols
definitions. Note the ';' character at the end of each macro. This is the end
statement character and it is mandatory.
Any regular grammar definition must contain one and only one symbol block
definition.

Next, we have the group definitions block. This is a mandatory element of a
grammar definition. A group block definition is defined by a starting macro
named 'BEGIN_GROUPS;' (without quotes) and ends with an ending macro named
'END_GROUPS;' (without quotes). Between these 2 macro usage, there are groups
definitions. Note the ';' character at the end of each macro. This is the end
statement character and it is mandatory.  Any regular grammar definition must
contain one and only one group block definition.

Finally, there is another main entity that is similar to the document line in
its meaning. This is the white space characters. White space characters are the
space : ' ', the horizontal tab : '	', the end line characters : '\n' and '\r'.
Like the documentation block, the white space characters don't have any meaning
in grammar interpretation but they could be used as symbols if escaped (we'll
see that later)

To summarize, a warp regular grammar definition string is built with :
- one or several documentation blocks placed between grammar entities,
- one and only one symbol definition block, defined before the group definition
  block,
- one and only one group definition block, defined after the symbol definition
  block,
- one or several white space characters.

Here is an overview of a warp regular grammar definition string, in C++ the
language :

auto warp_regular_grammar_definition_string =
  "/* This is an overview. Go ahead and read next chapters in order to see how"
  " * is built a true warp regular grammar definition. Note that this comment"
  " * block can contain any character and is ended here. */"

  "/* Mandatory symbol definition block. Must be defined only once and before"
  " * the group block definition. */"
  "BEGIN_SYMBOLS;"
  "/* contains all symbol definitions. More on that later. */"
  "END_SYMBOLS;"

  "/* Mandatory group definition block. Must be defined only once and after"
  " * the group block definition. Note that you can use raw string literal. */"
  R"groups(
  BEGIN_GROUPS;
  /* contains all group definitions. more on that later. */
  END_GROUPS;
  )groups"

    1.1.2°) Writing symbols
    -----------------------
This section describes how to write symbol defintions inside a symbol definition
block.
A symbol is a logical object that can be compared to a single letter (for
instance a 'b'). A symbol can be a letter or anything but some letters.

Considering this, there is two categories of symbol : inclusive and exclusive.
An inclusive symbol represents a letter (just like 'c'). An exclusive symbol is
any letter but those specified. it can be seen as a negative character class in
a regular expression (for instance [^abc] is anything but 'a', 'b' or 'c').

      1.1.2.1°) Simple symbols, inclusive and exclusive
      -------------------------------------------------
There is several way to write symbol. The basic form is presented here, inside a
symbol group definition :

a = a;

Pretty simple isn't it? This line define a symbol named 'a', recognizing the 'a'
letter. The left hand side of this definition is the symbol name. An equal sign
define the value of a symbol, the right hand side is the symbol value. The
finishing semicolon is mandatory and denotes the end of the symbol definition.
An inclusive symbol definition can only recognize a single letter, here the 'a'.

Below is another example of symbol definition, but, this is an exclusive one
that is defined here :

no_digit = -0123456789;

Here, the symbol name is 'no_digit'. It is an exclusive symbol because the right
hand side of the symbol definition begin with a '-' character.
An exclusive symbol definition can recognize all character but those specified
after the '-' meta-character, here, this symbol can recognize any letter but 0,
'1','2','3','4','5','6','7','8' and '9'.
Note that symbol name must be unique throughout the symbol definitino block.
Giving the same name to several symbol is invalid.

      1.1.2.2°) Meta-characters for symbol definitions
      ------------------------------------------------
A meta character for a symbol definition is a character that has a special
meaning. Such a character cannot be used as is in a symbol definition without
altering the symbol definition itself. Below is a list of each meta character
that one can find in a symbol definition and how they can be used.

        1.1.2.2.1°) The '-' meta character
        ----------------------------------
Allows the definition of exclusive symbols. An exclusive symbol is a symbol that
recognizes all but letter specified, just like the negative character class of a
regular expression.
To obtain its meta-meaning, the '-' symbol must be specified as the first
character in the right hand-side of the symbol definition. If placed elsewhere
in the symbol definition, it loses its meta-meaning and is considered as a raw
'-' character.

        1.1.2.2.2°) The '=' meta character
        ----------------------------------
The assignation meta-character is the link between a symbol name and the letter
it recognize or letters it doesn't recognize. To obtain its meta-meaning the '='
character must be placed between the symbol name and the symbol defintion. As a
result, the '=' character is illegal in a symbol name and subsequent uses of '='
in the symbol definition are treated just as raws '=' characters.

        1.1.2.2.3°) The ';' meta character
        ----------------------------------
This is the end of symbol definition character. Each symbol definition must be
terminated by a ';'. Though it is a meta-character, the ';' gains its
meta-meaning only at the ultimate end of a symbol definition and, as a result,
can be used in symbol names.

        1.1.2.2.4°) The 'white spaces' meta characters
        ----------------------------------------------
These meta-characters are a bit special as they don't possess a real
meta-meaning. Therefore, they can be used as separator to enhance the
readability of symbol definitions. A white space character is either a space
(' '), an horizontal tab ('\t') or an end of line ('\r', '\n'). Besides being
used to enhance readability of symbol definitions, they also can be used between
mais grammar definition entities (documentation blocks, symbol and group
defintion blocks, symbol and group definitions, symbol and group names and their
definition at right hand side). As a consequence, white space meta-characters
cannot be used as symbol names.

        1.1.2.2.5°) The '`' pairs meta character
        ----------------------------------------
These are a special beast. First, they are used to escape the meta-meaning of
other meta-character (including the '`'). Second, they have to be used as pair
to be effective : each meta-character inside a pair of '`' loose immediately its
meta-meaning. They can only be used in the right hand side of a symbol
definition and the opening '`' must be the first character for an inclusive
symbol definition. It must be the first character specified after the '-' in the
case of an exclusive symbol definition. If not specified at first character
after the '-' meta-character, the '`' immediately looses its meta-meaning (only
applies when defining an exclusive symbol). Using a pair of '`' with nothing
inside is invalid. If you want to escape the '`' character, it must be the first
character specified right after the opening '`' of the pair both for an
exclusive symbol definition and an inclusive symbol definition (that can only
take care of an unique letter anyway).
More examples of usage later.

      1.1.2.3°) Defining symbols with macros
      --------------------------------------
Examples above show how to define symbols with an unitary manner. Defining a lot
of symbol this way could be cumbersome and error-prone. Symbol definition macros
are here to solve these issues.

        1.1.2.3.1°) The BASIC_SYMBOLS macro
        -----------------------------------
This macro is designed to be used as a shortcut to define several INCLUSIVE
symbols at once. The way it works is simple, it defines as much as symbols
specified those the name is strictly equal to the letter that is recognized. As
usula, this statement must be terminated by a ';' meta-character.
It is good to know that there is some limit in letter used with this method. All
rules that are in place for symbol names apply on symbol definition with this
macro. As a result, you cannot use white spaces and the '=' letter with this
macro as it could lead to attempt to create symbol with a white space or an '='
name, that is illegal. Using this macro is also a way to escape the meta-meaning
of some meta-characters (except '=' and white spaces). As above, the usage of
this macro is restricted in a symbol definition block.
Here is an example of this macro usage :

BASIC_SYMBOLS helowrd;

The BASIC_SYMBOLS usage above is strictly similar to :

h = h;
e = e;
l = l;
o = o;
w = w;
r = r;
d = d;

I'm sure it won't be hard to convince you that using this macro is helpful when
dealing with simple inclusive symbols.

    1.1.3°) Writing groups
    ----------------------
This section describes how to write group definitions inside a group definition
block. A group is a logical object on which user can apply a closure. A group is
made of few things, formerly, a name, a symbol or another group, a closure to
apply on it. As a group element can be a symbol, it explains why symbols must be
defined before groups. It doesn't exist several types of group but groups behave
differently regarding the closure that is applied on it.
Syntax to write group definitions is quite similar to the symbol definition one.
It just has been added few new meta-character to represent the closure
operations that can be applied on groups. However, name resolution lookups are
made to ensure the validity of group definition thus, the order the user write
group definitions definitely matters.
As one of the main entity of the grammar definition, groups are the first class
citizens of it and, hold a crucial role in a language recognition. Indeed, the
LAST group that is defined in the group definition block of the grammar is the
one that recognizes the full language that is input by the user. Sub-sections
belows present how to build valid group definitions.
Here is the basic anatomy of one of a the most simple group definition :

group_name = symbol_name ;
+--------- + +---------- +
|          | |           `->This is the terminal meta-character giving an end to
|          | |              the group definition.
|          | `->This is a symbol name used in the group definition statement.
|          |    A symbol with this name must be defined in the symbol definition
|          |    block
|          `->This is the affectation symbol. It is a meta-character with the
|             same meta-meaning as it has for a symbol definition.
`->This is the group name. It must be unique througout the group definition
   block

The group defined above is one of the simple group you can define. It only apply
a one to one closure on an existing symbol.

      1.1.3.1°) Rules to write valid groups
      -------------------------------------
Like as symbol definition, user has to respect a set of rule to ensure writing
valid group definition.
First, a group definition can only be written within a group definition block.
Then, group's name has to respect the same rules as the symbol's name that is :
- no white space character (' ', '\t', '\n', '\r')
- no '=' character
Then, a group name must be followed by an '=' meta-character affecting a group
definition to the group name (just like a symbol definition).
Then, the group definition righ hand side statement must be written.
Finally, a terminal ';' must be written to end the group definition.

      1.1.3.2°) Use closure in group definitions
      ------------------------------------------
The main feature that is given to a group is the ability to apply closure on
either a previously defined symbol or group. These closure could also be called
quantifiers and are very similar to quantifers used in regular expressions.
There are two kind of closure :
- Unary, that apply on a single entity (either a symbol or a group)
- Binary, that only apply on two entity of group type.
Thus, using binary in a group definition using a symbol is invalid.
Hence, rules that must be respected to define a group may change, depending the
closure type that is used to define the group.

        1.1.3.2.1°) Unary closures
        --------------------------
This kind of closure is usable with group using either a symbol or a group as
operand. It operates on an unique entity, that's why it's called unary.
Such closures can be represented as quantifier in the regular expression world.
Below is a description of each closure. As this kind of closure can operate on
both symbol and group, it dictates how the name lookup works when resolving the
operand name that can be either a group or a symbol.

          1.1.3.2.1.1°) Name resolution lookup
          ------------------------------------
This process is related on how to find the entity targeted by the name specified
in the group on which the unary closure apply. As unary closure can perform on
both symbol or group, the name resolution could take place in two ways :
- if a group is found with the name specified in the group definition, the name
  resolution lookup is finished and the found group will be used to apply the
  closure on.
- otherwise the name resolution lookup does ot find any group, the process is
  repeated in the symbol definition block. If a symbol is found whith the name
  specified in the group definition, the name resolution lookup is finished and
  the found symbol will be used to apply the closure on.
It is important to note that the name resolution lookup proceed in the order
specified above : first an attempt to find a group in the group definition block
is done, then, if no group is found, the name resolution lookup takes place in
the symbol definition block.
At the end, if not any entity, either symbol or group is found, the grammar is
considered as invalid.

          1.1.3.2.1.2°) One to one
          ------------------------
This closure is somewhat a no-operation. It is not related to any known regular
expression quantifier. It can be considered as a '1 factor' for an arithmetic
expression. As a result, applying this closure on a symbol or a group do...
well... nothing on particular.
In a group definition, this closure has no meta-character to represent it. Thus,
not specifying a closure meta-character for a group definition means to use the
one-one closure.
For example :

a = a;

Above is a group definition using the 'a' group or symbol and applying a one-one
closure on it.

          1.1.3.2.1.3°) One to many
          -------------------------
This closure is one of the fundamental ones (with one to one and zero to one).
It consist to make a repetition with the group or the symbol that is specified
as operand in the group definition. In that sense, it is strictly identical to
the '+' quantifier of a regular expression. By the way, the meta-character that
represents this closure is '+'.
As an example :

a+ = a+;

Is a group definition defining the group names 'a+' and applying the one to many
closure on the a group or symbol.

          1.1.3.2.1.4°) Zero to one
          -------------------------
One of the fundamental closure (with one to one and zero to many). This closure
consist to make the group or symbol operand in the group definition optional. It
is strongly related with the '?' quantifier of regular expression world.
For instance :

a? = a?

Defines the group repeating the group or the symbol named 'a' zero or one time.
It won't be a suprise if I told you that the meta-character to use in order to
apply this closure in your group definition is '?'.

          1.1.3.2.1.5°) Zero to many
          --------------------------
Despite its name, the zero to many is not stricto sensu a closure but a
composition of two existing and previsously presented closures. Actually,
applying this closure on a group or symbol operand has the same effect to apply
first a one to many closure then a zero to one closures. Anyway, this closure
has its own meta-character that is '*'; the same as the regular expression's
Kleen's star.
Using it in a group definition gives :

a* = a*;

Above is defined a group named 'a*' applying the zero to many closure on the a
group or symbol.

        1.1.3.2.2°) Binary closures
        ---------------------------
