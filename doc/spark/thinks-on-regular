This is the roadmap to develop further spark, the formal language features
branch of warp.

This document describes the regular language support.

The first step for spark implementation is to create a grammar that is closely
related to regular language feature, some sort of regular grammar, that looks
like an EBNF form of more complicated grammar that could be found elsewhere.

Regular grammar definition :
----------------------------
  This grammar must be able to be parsed by a regular grammar.
  I think I'll create a group type that can parse this kind of grammar.
  Hence, the next step will be to provide a type that can instantiate built
  compile-time automaton. These 'runtimed' automata will be able to parse this
  regular grammar to ensure its correctness.

  How does it looks like?
  -----------------------
  User could use extended raw string exposed by c++ as well as more old-styled
  strings :

  auto simple_regular_grammar_definition =
    R"grammar(
    # This is a documentation line. Each documentation line must be enclosed   #
    # by a pair of ## characters. Documentation lines can be mixed together    #
    # just like this : ##another infos# #last infos                            #
    # These documentation lines are just for the user of the grammar and are   #
    # not usefull to create the parser.                                        #
    # Moreover, documentation lines can be inserted everywhere in the grammar  #
    # definition but cannot be interlaced with other grammar entity            #
    # like groups or symbols.                                                  #
    # You can put any end line you want and where you want as well as white    #
    # spaces unless it breaks the syntax of the grammar definition             #

    # MANDATORY section of a regular grammar definition. This section will     #
    # contain all symbols that can be used in a group definition. Even the     #
    # simplest grammar must define at least one symbol. Although it is not an  #
    # optimal way to proceed, all symbols that are defined below are not       #
    # mandatory used in further groups. This section ends with a semicolon.    #
    # The BEGIN_SYMBOLS section must be the first one defined entity container #
    # in the grammar definition.                                               #
    #                                                                          #
    BEGIN_SYMBOLS; # Note the semicolon at the end of the block name           #

      # This is a really simple symbol representing the 'a' letter. Note the   #
      # semicolon at the end of the definition. The semicolon is mandatory.    #
      a = a;
    # ^   ^                                                                    #
    # |   |                                                                    #
    # |   +- symbol value                                                      #
    # +- symbol name, used in group definitions                                #

      # This is a really simple symbol representing the 'b' letter.            #
      b = b;

      # A single letter can also be defined inside a pair of braces. A pair of #
      # brace nullifies all special meaning of meta character. Meta-characters #
      # for symbols are :                                                      #
      # white spaces : are completely ignored                                  #
      # '.' for the any-character concept                                      #
      # '-' for the exclusive symbol definition (all but that is written after #
      #     the minus sign)                                                    #
      # braces : a full pair of braces can be used to nullify any meta         #
      #          characters, semicolon included                                #
      # ';' for the end of statement meaning.                                  #
      c = [c]; # this is the same as c = c;                                    #

      # If you want to recognize a white space define its representation       #
      # inside a brace pair                                                    #
      white_space = [ ];
      horizontal_tab = [	];

      # Recognize the semicolon character                                      #
      semicolon = [;];

      # The same as above but for the d letter                                 #
      d = [d]; # same as  d = d;                                               #

      # The any letter concept. Must be specified nude, aka not within a brace #
      # pair. Indeed, a brace pair nullify the any meaning of '.'              #
      any = .;

      # The '.' character, losing it special meaning inside a brace pair.      #
      dot = [.];

      # The '-' character, losing it special meaning inside a brace pair.      #
      minus = [-];

      # The '-' character, specified alone, doesn't have its special meaning   #
      minus = -;

      # This symbol is an exclusive symbol. It means that the letter sequence  #
      # defined after the affectation sign represent all the letter we don't   #
      # want to be recognized by the symbol. An exclusive symbol is prefixed   #
      # by the '-' meta character. The '-' must be specified at the first      #
      # position of the right operand of the symbol and out of a brace pair    #
      # otherwise, it loses it special meanings and is considered as a raw '-' #
      # character like any others.                                             #
      # IMPORTANT NOTE : only exclusive symbol can define sequence of letter.  #
      #                  inclusive symbol (not prefixed by '-' can have only   #
      #                  one letter or 'any' assignation. By the way, it is    #
      #                  impossible to use the special meaning of '.' in an    #
      #                  exclusive symbol definition.                          #
      all_but_dot = -.;

      # all but digit characters. note the '-' at the start of the letter      #
      # sequence meaning we consider all characters are valid but digits.      #
      all_but_digit = -0123456789;

      # The same rule as above, just applied to lowercase letters. Note that   #
      # the sequence can also be defined inside a brace pair though it is      #
      # absolutely not necessary because all character  in the brace pair      #
      # don't have any special meaning                                         #
      all_but_lowercase_letters = -[abcdefghijklmnopqrstuvwxyz];

      # If a brace character is specified alone, it loses its special meaning  #
      left_brace = [;
      right_brace = ];
      # This behavior is similar to the '-' character                          #

      # These symbol definitions are identical and consist to recognize any    #
      # input that does not match with any symbol meta-characters. The first 2 #
      # don't exclude the semicolon meta-character                             #
      #                                                                        #
      # Note how braces are written here                                       #
      all_but_meta_1 = -][.-;
      # all_but_meta_1 = -[].-;  is an error as brace content is not           #
      # considered valid (not finished)                                        #

      # OK, all lose their special meaning                                     #
      all_but_meta_2 = --[.];
      # Braces are not meta here because not just right after the '-'          #

      # OK as the right brace is right after the opening one that is meta. The #
      # semicolon is handled here.                                             #
      all_but_meta_3 = -[]-.;[];

      # To summarize the symbol section definition :                           #
      # - The couple 'BEGIN_SYMBOLS;/END_SYMBOLS;' is mandatory in the         #
      #   grammar definition string and must be the first container defined in #
      #   the grammar.                                                         #
      # - Each symbol definition is built with 3 parts :                       #
      #   - A name declaration (single word, [^= \n\r\t\v]+)                   #
      #   - An affectation sign '=' prefixed and/or postfixed by an arbitrary  #
      #     number of whitespace characters                                    #
      #   - The definition (see examples above)                                #
      # - Each symbol definition must be terminated by a semicolon character.  #
      # - A symbol definition can be :                                         #
      #   - Inclusive (uses only one letter that may be inside a brace pair to #
      #     nullify some meta meaning)                                         #
      #   - Exclusive (uses a sequence of one or more letter prefixed by '-'   #
      #     character. The sequence letter may be contained inside a brace     #
      #     pair                                                               #
      # - A brace pair usage nullifies all meaning of meta character placed    #
      #   inside it both for inclusive and exclusive symbol.                   #
      # - Meta characters are applicable in the right hand side of the symbol  #
      #   definition and are from the following list :                         #
      #    - ';' end a symbol definition                                       #
      #    - '.' means 'any character'                                         #
      #    - '-' specified at the begining of a letter sequence, means that    #
      #      the symbol recognize all letter but those specified.              #
      #    - '[]' The brace pair is not a single meta character but have its   #
      #      own meaning, nullifying any special meaning of meta character,    #
      #      allowing them to be recognized as standard characters by the      #
      #      symbol. See above for examples.                                   #
      # - Though it is not optimal, it is possible to define symbols that are  #
      #   never used further in any group.                                     #
    END_SYMBOLS; # Terminates the symbol definitions                           #

    # MANDATORY section of a regular grammar definition. Contains at least one #
    # group that describe the grammar able to recognize a regular language.    #
    # A group works ONLY with defined symbols in 'BEGIN_SYMBOLS;/END_SYMBOLS;' #
    # section and groups that are PREVIOUSLY defined.                          #
    #                             ----------                                   #
    # The name resolution to know if an entity is a symbol or a group takes    #
    # place in this order :                                                    #
    # - First, look inside previsouly defined group. If one is found, use it.  #
    # - Last, if not any group is found, take a look in symbols.               #
    # If more than one group names are resolved (several groups have the same  #
    # name) an error will occur. There is some sort of ODR in the grammar      #
    # definition.                                                              #
    # The grammar recognize any language that is parsed by the LAST group      #
    #                                                          ----            #
    # defined in this section. This section must contain at least one group    #
    # definition                                                               #
    BEGIN_GROUPS;
      # A simple group definition, using a previously defined symbol and       #
      # applying an unary closure (Kleen's star) on it                         #
      # The '*' closure is available for both symbol and group values          #
      a* = a*;

      # This group is even simpler than the previously defined one. It uses    #
      # the b symbol defined above as is                                       #
      b = b;

      # You can enclose the symbol name in a brace pair. It is usefull if the  #
      # the symbol name contains some meta character relative to right hand    #
      # side group definition (closure characters and semicolon) though not    #
      # absolutely necessary in this case (see above).                         #
      c = [c];

      # This group uses the 'd' symbol and applies on it the '?' closure that  #
      # means 'recognize zero or one occurence of the symbol'                  #
      # NOTE that you can put any number of white space characters between the #
      # symbol and the closure meta-character.                                 #
      # The '?' closure is available for both symbol and group values          #
      d? = d ?;

      # This group uses previously defined group that used symbols and unary   #
      # closures (quantifiers). The closure used here is the concatenation     #
      # and the only valid operands are previously defined group.              #
      # Consequently, the order of group definition matters.                   #
      # The '.' closure is only valid for use with group values, not symbol    #
      cd? = c . d?;

      # Uses the alternation closure with previsouly defined groups            #
      # The '|' closure is only valid for use with group values, not symbol    #
      # Group value is read from left to right, no brace pair needed on cd?    #
      b|cd? = b | cd?;

      # This group use an unary closure on another group. The usage of the     #
      # brace pair is absolutely mandatory because b is a previsouly           #
      # defined group as well as b|cd?. If 'b' is resolved, '|' will be        #
      # considered as the binary closure instead as a part of a group name     #
      (b|cd?)+ = [b|cd?]+;

      # This is the last group defined, so the final regular grammar           #
      # definition.                                                            #
      # Group value is read from left to right, brace pair necessary around a* #
      # to prevent error.                                                      #
      a*(b|cd?)+ = [a*] . (b|cd?)+;

      # Summary of group definition and composition :                          #
      # - The couple 'BEGIN_GROUPS;/END_GROUPS;' is mandatory in the           #
      #   grammar definition string and must be define AFTER symbol            #
      #   definitions                                                          #
      # - Each group definition is built with 3 parts :                        #
      #   - A name declaration (single word, [^= \n\r\t\v]+)                   #
      #   - An affectation sign '='                                            #
      #   - The definition (see examples above)                                #
      # - Each group definition must be terminated by a semicolon character.   #
      # - At least one must exist inside the section                           #
      # - The last group defined decides of the languages recognized by the    #
      #   grammar.                                                             #
      # - Contrary on symbols definitions, group definitions rely on           #
      #   previously defined entities (either symbol or groups). Trying to     #
      #   refer to an unexisting symbol or group within a group definition is  #
      #   an error.                                                            #
      # - The brace pair is also available in group definition. It may be      #
      #   usefull to express clearly the right hand side part of a group       #
      #   definition; it is mandatory when the right hand side part of the     #
      #   group definition contains group's names made with meta-characters.   #
      # - Meta characters for groups  are :                                    #
      #   - ';' : this one has the same meaning for groups and symbols. It     #
      #           terminates the group definition.                             #
      #   - '[]' : the brace pair have the same purpose for symbols and groups #
      #            definitions. It could be used for the sake of clarity or to #
      #            disambiguate group's names containing some meta characters. #
      #   - '?' : means 0 to 1 quantifier. It is an unary closure that can be  #
      #           used either on a previously defined symbol OR on a           #
      #           previously defined group.                                    #
      #   - '*' : means 0 to n quantifier. It is an unary closure that can be  #
      #           used either on a previously defined symbol OR on a           #
      #           previously defined group.                                    #
      #   - '+' : means 0 to n quantifier. It is an unary closure that can be  #
      #           used either on a previously defined symbol OR on a           #
      #           previously defined group.                                    #
      #   - '.' : this is the concatenation binary closure. Contrary on unary  #
      #           closures, binary closures can only be used on 2 group        #
      #           operands.                                                    #
      #   - '|' : this is the alternation binary closure. Contrary on unary    #
      #           closures, binary closures can only be used on 2 group        #
      #           operands.                                                    #
      # - The last group that is defined rules the entire grammar and defines  #
      #   which languages are recognized by this one.                          #
    END_GROUPS;

    # That's it for the grammar definition string. Here, you can see that some #
    # symbols are unused. It is not an error, and they can be safely deleted.  #

    # Below is an example of the simplest regular grammar definition you can   #
    # do :                                                                     #

    # BEGIN_SYMBOLS;                                                           #
    #   a = a;                                                                 #
    # END_SYMBOLS;                                                             #

    # BEGIN_GROUPS;                                                            #
    #   a = a;                                                                 #
    # END_GROUPS;                                                              #

    # That's it! This regular grammar only recognize the 'a' letter.           #

    )grammar";

  Transform a grammar definition string into an expression template
  -----------------------------------------------------------------
  Above is described how an user can define a regular grammar. Such a regular
  grammar string can be 'transformed' into an expression template using some
  meta feature warp exposes (integral sequences especially).
